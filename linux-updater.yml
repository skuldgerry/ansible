---
- name: Update all Linux nodes
  hosts: all
  become: yes
  gather_facts: yes
  serial: 2  # Process only 2 servers at a time
  any_errors_fatal: false  # Continue even if some hosts fail
  max_fail_percentage: 50  # Allow up to 50% of hosts to fail before stopping
  
  # Connection settings to prevent hanging on unreachable hosts
  vars:
    ansible_command_timeout: 30
    ansible_connect_timeout: 30
    lock_file_path: /tmp/ansible-updater.lock
    package_timeout_initial: 300   # 5 minutes for first attempt
    package_timeout_retry: 1800    # 30 minutes for retry attempt
    cache_timeout: 600             # 10 minutes max for cache updates
  
  # Pre-tasks: Lock file mechanism to prevent concurrent execution
  pre_tasks:
    - name: Check for existing lock file
      ansible.builtin.stat:
        path: "{{ lock_file_path }}"
      register: lock_file
      delegate_to: localhost
      run_once: true
      become: false  # Don't require sudo for localhost operations
    
    - name: Check if lock file is stale (older than 4 hours)
      ansible.builtin.stat:
        path: "{{ lock_file_path }}"
      register: lock_file_stale
      delegate_to: localhost
      run_once: true
      become: false
      when: lock_file.stat.exists | default(false)
    
    - name: Remove stale lock file
      ansible.builtin.file:
        path: "{{ lock_file_path }}"
        state: absent
      delegate_to: localhost
      run_once: true
      become: false
      when: 
        - lock_file.stat.exists | default(false)
        - (ansible_date_time.epoch | int) - (lock_file_stale.stat.mtime | int) > 14400  # 4 hours in seconds
      failed_when: false
    
    - name: Fail if lock file exists (another instance is running)
      ansible.builtin.fail:
        msg: "Another update playbook is already running. Lock file exists at {{ lock_file_path }}. If this is stale, remove it manually."
      when: 
        - lock_file.stat.exists | default(false)
        - not ((ansible_date_time.epoch | int) - (lock_file_stale.stat.mtime | int) > 14400)
      delegate_to: localhost
      run_once: true
      become: false
    
    - name: Create lock file
      ansible.builtin.file:
        path: "{{ lock_file_path }}"
        state: touch
        mode: '0644'
      delegate_to: localhost
      run_once: true
      become: false
      failed_when: false
    
    - name: Set lock file content with timestamp
      ansible.builtin.copy:
        content: "Locked by Ansible at {{ ansible_date_time.iso8601 }} - PID: {{ ansible_env.PID | default('unknown') }}"
        dest: "{{ lock_file_path }}"
        mode: '0644'
      delegate_to: localhost
      run_once: true
      become: false
    
    - name: Initialize upgrade status tracking
      ansible.builtin.set_fact:
        upgrade_status: "pending"
      failed_when: false
  
  tasks:
    # ============================================
    # PHASE 1: Initial attempt with 5-minute timeout
    # ============================================
    
    # Debian-based systems - Phase 1
    - name: Update package manager cache (Debian-based) - Phase 1
      block:
        - name: Update apt cache with timeout
          ansible.builtin.shell: |
            timeout {{ cache_timeout }} apt-get update
          args:
            executable: /bin/bash
          register: apt_cache_result
          failed_when: false
      rescue:
        - name: Log cache update failure (Debian)
          ansible.builtin.debug:
            msg: "Failed to update cache on {{ inventory_hostname }}. Continuing..."
      when: ansible_os_family == "Debian"
      ignore_errors: yes
    
    - name: Upgrade packages (Debian-based) - Phase 1 - Initial 5min attempt
      block:
        - name: Upgrade packages with 5-minute timeout
          ansible.builtin.shell: |
            timeout {{ package_timeout_initial }} apt-get upgrade -y -o Dpkg::Options::="--force-confold" && \
            apt-get autoremove -y && \
            apt-get autoclean -y
          args:
            executable: /bin/bash
          register: apt_upgrade_phase1
          failed_when: false
        
        - name: Check if Phase 1 upgrade succeeded
          ansible.builtin.set_fact:
            upgrade_status: "{{ 'success' if apt_upgrade_phase1.rc == 0 else 'timeout' }}"
          when: apt_upgrade_phase1.rc is defined
        
        - name: Log Phase 1 success (Debian)
          ansible.builtin.debug:
            msg: "Package upgrade completed successfully on {{ inventory_hostname }} in Phase 1"
          when: upgrade_status == "success"
        
        - name: Log Phase 1 timeout (Debian)
          ansible.builtin.debug:
            msg: "Package upgrade timed out on {{ inventory_hostname }} in Phase 1 (5 min). Will retry in Phase 2."
          when: upgrade_status == "timeout"
      rescue:
        - name: Mark as timeout on error (Debian)
          ansible.builtin.set_fact:
            upgrade_status: "timeout"
        - name: Log Phase 1 error (Debian)
          ansible.builtin.debug:
            msg: "Package upgrade error on {{ inventory_hostname }} in Phase 1. Will retry in Phase 2."
      when: ansible_os_family == "Debian"
      ignore_errors: yes
    
    # RHEL-based systems - Phase 1
    - name: Update package manager cache (RHEL-based) - Phase 1
      block:
        - name: Update yum cache with timeout
          ansible.builtin.shell: |
            timeout {{ cache_timeout }} yum makecache
          args:
            executable: /bin/bash
          register: yum_cache_result
          failed_when: false
      rescue:
        - name: Log cache update failure (RHEL)
          ansible.builtin.debug:
            msg: "Failed to update cache on {{ inventory_hostname }}. Continuing..."
      when: ansible_os_family == "RedHat"
      ignore_errors: yes
    
    - name: Upgrade packages (RHEL-based) - Phase 1 - Initial 5min attempt
      block:
        - name: Upgrade packages with 5-minute timeout
          ansible.builtin.shell: |
            timeout {{ package_timeout_initial }} yum update -y
          args:
            executable: /bin/bash
          register: yum_upgrade_phase1
          failed_when: false
        
        - name: Check if Phase 1 upgrade succeeded
          ansible.builtin.set_fact:
            upgrade_status: "{{ 'success' if yum_upgrade_phase1.rc == 0 else 'timeout' }}"
          when: yum_upgrade_phase1.rc is defined
        
        - name: Log Phase 1 success (RHEL)
          ansible.builtin.debug:
            msg: "Package upgrade completed successfully on {{ inventory_hostname }} in Phase 1"
          when: upgrade_status == "success"
        
        - name: Log Phase 1 timeout (RHEL)
          ansible.builtin.debug:
            msg: "Package upgrade timed out on {{ inventory_hostname }} in Phase 1 (5 min). Will retry in Phase 2."
          when: upgrade_status == "timeout"
      rescue:
        - name: Mark as timeout on error (RHEL)
          ansible.builtin.set_fact:
            upgrade_status: "timeout"
        - name: Log Phase 1 error (RHEL)
          ansible.builtin.debug:
            msg: "Package upgrade error on {{ inventory_hostname }} in Phase 1. Will retry in Phase 2."
      when: ansible_os_family == "RedHat"
      ignore_errors: yes
    
    # Fedora-based systems - Phase 1
    - name: Update package manager cache (Fedora-based) - Phase 1
      block:
        - name: Update dnf cache with timeout
          ansible.builtin.shell: |
            timeout {{ cache_timeout }} dnf makecache
          args:
            executable: /bin/bash
          register: dnf_cache_result
          failed_when: false
      rescue:
        - name: Log cache update failure (Fedora)
          ansible.builtin.debug:
            msg: "Failed to update cache on {{ inventory_hostname }}. Continuing..."
      when: ansible_distribution == "Fedora"
      ignore_errors: yes
    
    - name: Upgrade packages (Fedora-based) - Phase 1 - Initial 5min attempt
      block:
        - name: Upgrade packages with 5-minute timeout
          ansible.builtin.shell: |
            timeout {{ package_timeout_initial }} dnf update -y
          args:
            executable: /bin/bash
          register: dnf_upgrade_phase1
          failed_when: false
        
        - name: Check if Phase 1 upgrade succeeded
          ansible.builtin.set_fact:
            upgrade_status: "{{ 'success' if dnf_upgrade_phase1.rc == 0 else 'timeout' }}"
          when: dnf_upgrade_phase1.rc is defined
        
        - name: Log Phase 1 success (Fedora)
          ansible.builtin.debug:
            msg: "Package upgrade completed successfully on {{ inventory_hostname }} in Phase 1"
          when: upgrade_status == "success"
        
        - name: Log Phase 1 timeout (Fedora)
          ansible.builtin.debug:
            msg: "Package upgrade timed out on {{ inventory_hostname }} in Phase 1 (5 min). Will retry in Phase 2."
          when: upgrade_status == "timeout"
      rescue:
        - name: Mark as timeout on error (Fedora)
          ansible.builtin.set_fact:
            upgrade_status: "timeout"
        - name: Log Phase 1 error (Fedora)
          ansible.builtin.debug:
            msg: "Package upgrade error on {{ inventory_hostname }} in Phase 1. Will retry in Phase 2."
      when: ansible_distribution == "Fedora"
      ignore_errors: yes
    
    # ============================================
    # PHASE 2: Retry timed-out hosts with 30-minute timeout
    # ============================================
    
    - name: Display Phase 2 start message
      ansible.builtin.debug:
        msg: "Starting Phase 2: Retrying hosts that timed out in Phase 1"
      run_once: true
    
    # Debian-based systems - Phase 2
    - name: Upgrade packages (Debian-based) - Phase 2 - Retry with 30min timeout
      block:
        - name: Retry upgrade with 30-minute timeout
          ansible.builtin.shell: |
            timeout {{ package_timeout_retry }} apt-get upgrade -y -o Dpkg::Options::="--force-confold" && \
            apt-get autoremove -y && \
            apt-get autoclean -y
          args:
            executable: /bin/bash
          register: apt_upgrade_phase2
          failed_when: false
        
        - name: Update upgrade status after Phase 2
          ansible.builtin.set_fact:
            upgrade_status: "{{ 'success' if apt_upgrade_phase2.rc == 0 else 'failed' }}"
          when: apt_upgrade_phase2.rc is defined
        
        - name: Log Phase 2 success (Debian)
          ansible.builtin.debug:
            msg: "Package upgrade completed successfully on {{ inventory_hostname }} in Phase 2"
          when: upgrade_status == "success"
        
        - name: Log Phase 2 failure (Debian)
          ansible.builtin.debug:
            msg: "Package upgrade failed or timed out on {{ inventory_hostname }} in Phase 2 (30 min). Manual intervention required."
          when: upgrade_status == "failed"
      rescue:
        - name: Mark as failed after Phase 2 error (Debian)
          ansible.builtin.set_fact:
            upgrade_status: "failed"
        - name: Log Phase 2 error (Debian)
          ansible.builtin.debug:
            msg: "Package upgrade error on {{ inventory_hostname }} in Phase 2. Manual intervention required."
      when: 
        - ansible_os_family == "Debian"
        - upgrade_status == "timeout"
      ignore_errors: yes
    
    # RHEL-based systems - Phase 2
    - name: Upgrade packages (RHEL-based) - Phase 2 - Retry with 30min timeout
      block:
        - name: Retry upgrade with 30-minute timeout
          ansible.builtin.shell: |
            timeout {{ package_timeout_retry }} yum update -y
          args:
            executable: /bin/bash
          register: yum_upgrade_phase2
          failed_when: false
        
        - name: Update upgrade status after Phase 2
          ansible.builtin.set_fact:
            upgrade_status: "{{ 'success' if yum_upgrade_phase2.rc == 0 else 'failed' }}"
          when: yum_upgrade_phase2.rc is defined
        
        - name: Log Phase 2 success (RHEL)
          ansible.builtin.debug:
            msg: "Package upgrade completed successfully on {{ inventory_hostname }} in Phase 2"
          when: upgrade_status == "success"
        
        - name: Log Phase 2 failure (RHEL)
          ansible.builtin.debug:
            msg: "Package upgrade failed or timed out on {{ inventory_hostname }} in Phase 2 (30 min). Manual intervention required."
          when: upgrade_status == "failed"
      rescue:
        - name: Mark as failed after Phase 2 error (RHEL)
          ansible.builtin.set_fact:
            upgrade_status: "failed"
        - name: Log Phase 2 error (RHEL)
          ansible.builtin.debug:
            msg: "Package upgrade error on {{ inventory_hostname }} in Phase 2. Manual intervention required."
      when: 
        - ansible_os_family == "RedHat"
        - upgrade_status == "timeout"
      ignore_errors: yes
    
    # Fedora-based systems - Phase 2
    - name: Upgrade packages (Fedora-based) - Phase 2 - Retry with 30min timeout
      block:
        - name: Retry upgrade with 30-minute timeout
          ansible.builtin.shell: |
            timeout {{ package_timeout_retry }} dnf update -y
          args:
            executable: /bin/bash
          register: dnf_upgrade_phase2
          failed_when: false
        
        - name: Update upgrade status after Phase 2
          ansible.builtin.set_fact:
            upgrade_status: "{{ 'success' if dnf_upgrade_phase2.rc == 0 else 'failed' }}"
          when: dnf_upgrade_phase2.rc is defined
        
        - name: Log Phase 2 success (Fedora)
          ansible.builtin.debug:
            msg: "Package upgrade completed successfully on {{ inventory_hostname }} in Phase 2"
          when: upgrade_status == "success"
        
        - name: Log Phase 2 failure (Fedora)
          ansible.builtin.debug:
            msg: "Package upgrade failed or timed out on {{ inventory_hostname }} in Phase 2 (30 min). Manual intervention required."
          when: upgrade_status == "failed"
      rescue:
        - name: Mark as failed after Phase 2 error (Fedora)
          ansible.builtin.set_fact:
            upgrade_status: "failed"
        - name: Log Phase 2 error (Fedora)
          ansible.builtin.debug:
            msg: "Package upgrade error on {{ inventory_hostname }} in Phase 2. Manual intervention required."
      when: 
        - ansible_distribution == "Fedora"
        - upgrade_status == "timeout"
      ignore_errors: yes
  
  # Post-tasks: Clean up lock file (always runs, even on failure)
  post_tasks:
    - name: Display final summary
      ansible.builtin.debug:
        msg: "Host {{ inventory_hostname }} final status: {{ upgrade_status | default('unknown') }}"
      failed_when: false
    
    - name: Remove lock file
      ansible.builtin.file:
        path: "{{ lock_file_path }}"
        state: absent
      delegate_to: localhost
      run_once: true
      become: false  # Don't require sudo for localhost operations
      failed_when: false
    
    - name: Display completion message
      ansible.builtin.debug:
        msg: "Update playbook completed. Lock file cleaned up."
      run_once: true
      failed_when: false
      become: false
